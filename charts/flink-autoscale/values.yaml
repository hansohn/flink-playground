# Global defaults for all jobs
# Can be overridden per-job in the jobs list below
defaults:
  image:
    repository: flink
    tag: "1.18-scala_2.12"
    pullPolicy: IfNotPresent

  # Persistent storage for Flink state (checkpoints/savepoints)
  # Survives pod deletion and enables proper state recovery
  persistence:
    enabled: true
    storageClassName: "standard"  # Kind's local-path provisioner
    size: "1Gi"

  jobManager:
    replicas: 1
    # CPU for Flink resource spec (numeric, in cores)
    cpu: 0.5
    # Memory for Flink resource spec (Kubernetes format)
    memory: "1024Mi"
    # Kubernetes pod resources (for podTemplate)
    resources:
      requests:
        cpu: "250m"
        memory: "1Gi"
      limits:
        cpu: "1"
        memory: "2Gi"

  taskManager:
    replicas: 1
    # CPU for Flink resource spec (numeric, in cores)
    cpu: 0.5
    # Memory for Flink resource spec (Kubernetes format)
    memory: "1024Mi"
    # Kubernetes pod resources (for podTemplate)
    resources:
      requests:
        cpu: "250m"
        memory: "1Gi"
      limits:
        cpu: "2"
        memory: "2Gi"
    slots: 2

  # VPA Configuration - DISABLED (incompatible with native mode)
  # Use Flink Autotuning instead for memory optimization
  vpa:
    enabled: false

  # Flink Kubernetes Operator Autoscaler Configuration
  autoscaler:
    enabled: true
    metricsWindow: "5m"
    stabilizationInterval: "1m"
    targetUtilization: "0.7"
    targetUtilizationBoundary: "0.1"
    scaleUpGracePeriod: "1m"
    scaleDownGracePeriod: "3m"
    minParallelism: 1
    maxParallelism: 10

# Define multiple Flink jobs
# Each job creates a separate FlinkDeployment (cluster + job)
jobs:
  # Example 1: Autoscaling Load Job
  - name: autoscaling-load
    enabled: true

    # Use custom image with JAR bundled
    image:
      repository: flink-autoscaling-load
      tag: "1.0.0"
      pullPolicy: IfNotPresent

    # Job specification (Application Mode)
    job:
      jarURI: "local:///opt/flink/usrlib/autoscaling-load-job.jar"
      entryClass: "com.example.flink.AutoscalingLoadJob"
      parallelism: 2
      # Use last-state to preserve autoscaler decisions and job state across restarts
      # PersistentVolumeClaim ensures checkpoints survive pod deletion
      upgradeMode: last-state
      state: running
      args: []

    # Override resources if needed
    jobManager:
      cpu: 0.5
      memory: "1024Mi"
      resources:
        requests:
          cpu: "250m"
          memory: "1Gi"
        limits:
          cpu: "1"
          memory: "2Gi"

    taskManager:
      cpu: 0.5
      memory: "1024Mi"
      resources:
        requests:
          cpu: "250m"
          memory: "1Gi"
        limits:
          cpu: "2"
          memory: "2Gi"
      slots: 2

    # Override VPA settings if needed (inherits from defaults if not specified)
    # vpa:
    #   enabled: true
    #   updateMode: "Auto"

    # Override autoscaler settings if needed
    autoscaler:
      enabled: true
      targetUtilization: "0.7"
      minParallelism: 1
      maxParallelism: 10

    # Additional Flink configuration
    # Using RocksDB state backend with PersistentVolumeClaim for state durability
    # Autoscaler parallelism decisions + job state persist across pod deletions
    # PVC ensures state survives pod restarts, scaling events, and image updates
    # For production:
    # - Use remote storage (S3, HDFS, etc.) for disaster recovery
    # - Configure RocksDB tuning parameters for workload
    # - Increase PVC size for large state
    flinkConfiguration:
      state.backend.type: rocksdb
      state.backend.incremental: "true"
      state.checkpoints.dir: file:///opt/flink/state/checkpoints
      state.savepoints.dir: file:///opt/flink/state/savepoints
      execution.checkpointing.interval: "30s"
      # Retain checkpoints when job is cancelled (for last-state/savepoint modes)
      execution.checkpointing.externalized-checkpoint-retention: RETAIN_ON_CANCELLATION
      # Prometheus metrics reporter
      metrics.reporter.prom.factory.class: org.apache.flink.metrics.prometheus.PrometheusReporterFactory
      metrics.reporter.prom.port: "9249"
      # Flink Autotuning - automatic memory optimization
      kubernetes.operator.job.autoscaler.memory.tuning.enabled: "true"
      kubernetes.operator.job.autoscaler.memory.tuning.overhead: "0.2"

  # Example 2: Analytics Pipeline (disabled by default)
  # Uncomment to enable
  # - name: analytics-pipeline
  #   enabled: false
  #
  #   job:
  #     jarURI: "local:///opt/flink/usrlib/analytics-pipeline.jar"
  #     entryClass: "com.example.flink.AnalyticsPipeline"
  #     parallelism: 4
  #     upgradeMode: savepoint
  #     state: running
  #
  #   autoscaler:
  #     enabled: true
  #     targetUtilization: "0.8"  # More aggressive scaling
  #     minParallelism: 2
  #     maxParallelism: 20
  #
  #   # Different VPA settings for this job
  #   vpa:
  #     enabled: true
  #     updateMode: "Auto"
  #     controlledResources:
  #       - "memory"
  #     minAllowed:
  #       memory: "512Mi"
  #     maxAllowed:
  #       memory: "4Gi"
  #
  #   taskManager:
  #     resources:
  #       requests:
  #         cpu: "500m"
  #         memory: "1Gi"
  #       limits:
  #         cpu: "2"
  #         memory: "2Gi"
  #     slots: 4

  # Example 3: Session Cluster (no job defined)
  # Uncomment to enable
  # - name: dev-session
  #   enabled: false
  #
  #   # No job section = Session Mode
  #   # Submit jobs manually via CLI/UI
  #
  #   # Disable autoscaler for session mode
  #   autoscaler:
  #     enabled: false
  #
  #   taskManager:
  #     replicas: 2
  #     slots: 4
